
#import <Foundation/Foundation.h>

@interface WithoutSoilData : NSObject

+ (instancetype)sharedInstance;

//: PUT
@property (nonatomic, copy) NSString *layoutHourFabricLogger;

//: HEAD
@property (nonatomic, copy) NSString *appTensionConfig;

//: AFSSLPinningModeNone
@property (nonatomic, copy) NSString *spacingDictionDrillSouthwestUtility;

//: https
@property (nonatomic, copy) NSString *themeInfraImagineTitle;

//: sessionConfiguration
@property (nonatomic, copy) NSString *colorSceneUtility;

//: <%@: %p, baseURL: %@, session: %@, operationQueue: %@>
@property (nonatomic, copy) NSString *themeStandId;

//: DELETE
@property (nonatomic, copy) NSString *styleIreConfig;

//: Unknown Pinning Mode
@property (nonatomic, copy) NSString *themeCommandPreference;

//: POST
@property (nonatomic, copy) NSString *componentQuantityKey;

//: identifier
@property (nonatomic, copy) NSString *commonArgumentTimer;

//: Invalid Security Policy
@property (nonatomic, copy) NSString *screenAlongPreference;

//: AFSSLPinningModeCertificate
@property (nonatomic, copy) NSString *commonStandConfig;

//: A security policy configured with `%@` can only be applied on a manager with a secure base URL (i.e. https)
@property (nonatomic, copy) NSString *themeSocietyDigitLargelyHelper;

//: PATCH
@property (nonatomic, copy) NSString *layoutRockInsertName;

//: GET
@property (nonatomic, copy) NSString *commonTopEvent;

//: Invalid parameter not satisfying: %@
@property (nonatomic, copy) NSString *screenRemSimpleId;

//: AFSSLPinningModePublicKey
@property (nonatomic, copy) NSString *colorDrillError;

@end

@implementation WithoutSoilData

//: AFSSLPinningModeNone
- (NSString *)spacingDictionDrillSouthwestUtility {
    if (!_spacingDictionDrillSouthwestUtility) {
		NSArray<NSString *> *origin = @[@"20", @"12", @"130", @"134", @"247", @"210", @"251", @"28", @"82", @"169", @"53", @"184", @"101", @"110", @"111", @"78", @"101", @"100", @"111", @"77", @"103", @"110", @"105", @"110", @"110", @"105", @"80", @"76", @"83", @"83", @"70", @"65", @"161"];
		NSData *data = [WithoutSoilData WithoutSoilDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        _spacingDictionDrillSouthwestUtility = [self StringFromWithoutSoilData:value];
    }
    return _spacingDictionDrillSouthwestUtility;
}

- (NSString *)StringFromWithoutSoilData:(Byte *)data {
    return [NSString stringWithUTF8String:(char *)[self WithoutSoilDataToCache:data]];
}

//: GET
- (NSString *)commonTopEvent {
    if (!_commonTopEvent) {
		NSArray<NSString *> *origin = @[@"3", @"5", @"19", @"76", @"201", @"84", @"69", @"71", @"16"];
		NSData *data = [WithoutSoilData WithoutSoilDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        _commonTopEvent = [self StringFromWithoutSoilData:value];
    }
    return _commonTopEvent;
}

- (Byte *)WithoutSoilDataToCache:(Byte *)data {
    int occupation = data[0];
    int themeConnect = data[1];
    for (int i = 0; i < occupation / 2; i++) {
        int begin = themeConnect + i;
        int end = themeConnect + occupation - i - 1;
        Byte temp = data[begin];
        data[begin] = data[end];
        data[end] = temp;
    }
    data[themeConnect + occupation] = 0;
    return data + themeConnect;
}  

+ (instancetype)sharedInstance {
    static WithoutSoilData *instance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        instance = [[self alloc] init];
    });
    return instance;
}

//: DELETE
- (NSString *)styleIreConfig {
    if (!_styleIreConfig) {
		NSArray<NSString *> *origin = @[@"6", @"11", @"189", @"201", @"139", @"174", @"203", @"111", @"207", @"251", @"226", @"69", @"84", @"69", @"76", @"69", @"68", @"5"];
		NSData *data = [WithoutSoilData WithoutSoilDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        _styleIreConfig = [self StringFromWithoutSoilData:value];
    }
    return _styleIreConfig;
}

//: AFSSLPinningModePublicKey
- (NSString *)colorDrillError {
    if (!_colorDrillError) {
		NSArray<NSString *> *origin = @[@"25", @"7", @"98", @"172", @"1", @"29", @"89", @"121", @"101", @"75", @"99", @"105", @"108", @"98", @"117", @"80", @"101", @"100", @"111", @"77", @"103", @"110", @"105", @"110", @"110", @"105", @"80", @"76", @"83", @"83", @"70", @"65", @"118"];
		NSData *data = [WithoutSoilData WithoutSoilDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        _colorDrillError = [self StringFromWithoutSoilData:value];
    }
    return _colorDrillError;
}

//: POST
- (NSString *)componentQuantityKey {
    if (!_componentQuantityKey) {
		NSArray<NSString *> *origin = @[@"4", @"7", @"72", @"111", @"74", @"37", @"167", @"84", @"83", @"79", @"80", @"35"];
		NSData *data = [WithoutSoilData WithoutSoilDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        _componentQuantityKey = [self StringFromWithoutSoilData:value];
    }
    return _componentQuantityKey;
}

//: A security policy configured with `%@` can only be applied on a manager with a secure base URL (i.e. https)
- (NSString *)themeSocietyDigitLargelyHelper {
    if (!_themeSocietyDigitLargelyHelper) {
		NSArray<NSString *> *origin = @[@"107", @"4", @"59", @"49", @"41", @"115", @"112", @"116", @"116", @"104", @"32", @"46", @"101", @"46", @"105", @"40", @"32", @"76", @"82", @"85", @"32", @"101", @"115", @"97", @"98", @"32", @"101", @"114", @"117", @"99", @"101", @"115", @"32", @"97", @"32", @"104", @"116", @"105", @"119", @"32", @"114", @"101", @"103", @"97", @"110", @"97", @"109", @"32", @"97", @"32", @"110", @"111", @"32", @"100", @"101", @"105", @"108", @"112", @"112", @"97", @"32", @"101", @"98", @"32", @"121", @"108", @"110", @"111", @"32", @"110", @"97", @"99", @"32", @"96", @"64", @"37", @"96", @"32", @"104", @"116", @"105", @"119", @"32", @"100", @"101", @"114", @"117", @"103", @"105", @"102", @"110", @"111", @"99", @"32", @"121", @"99", @"105", @"108", @"111", @"112", @"32", @"121", @"116", @"105", @"114", @"117", @"99", @"101", @"115", @"32", @"65", @"19"];
		NSData *data = [WithoutSoilData WithoutSoilDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        _themeSocietyDigitLargelyHelper = [self StringFromWithoutSoilData:value];
    }
    return _themeSocietyDigitLargelyHelper;
}

//: Unknown Pinning Mode
- (NSString *)themeCommandPreference {
    if (!_themeCommandPreference) {
		NSArray<NSString *> *origin = @[@"20", @"5", @"18", @"83", @"115", @"101", @"100", @"111", @"77", @"32", @"103", @"110", @"105", @"110", @"110", @"105", @"80", @"32", @"110", @"119", @"111", @"110", @"107", @"110", @"85", @"114"];
		NSData *data = [WithoutSoilData WithoutSoilDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        _themeCommandPreference = [self StringFromWithoutSoilData:value];
    }
    return _themeCommandPreference;
}

//: identifier
- (NSString *)commonArgumentTimer {
    if (!_commonArgumentTimer) {
		NSArray<NSString *> *origin = @[@"10", @"2", @"114", @"101", @"105", @"102", @"105", @"116", @"110", @"101", @"100", @"105", @"80"];
		NSData *data = [WithoutSoilData WithoutSoilDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        _commonArgumentTimer = [self StringFromWithoutSoilData:value];
    }
    return _commonArgumentTimer;
}

+ (NSData *)WithoutSoilDataToData:(NSArray<NSString *> *)value {
    NSMutableArray<NSString *> *array = [NSMutableArray arrayWithArray:value];
    NSInteger length = array.count;
    Byte *buffer = (Byte *)malloc(length + 1);
    for (int i = 0; i < length; i++) {
        buffer[i] = [array[i] intValue];
    }
    buffer[length] = 0;
    return [NSData dataWithBytesNoCopy:buffer length:length freeWhenDone:YES];
}

//: sessionConfiguration
- (NSString *)colorSceneUtility {
    if (!_colorSceneUtility) {
		NSArray<NSString *> *origin = @[@"20", @"11", @"102", @"139", @"223", @"210", @"22", @"198", @"133", @"226", @"189", @"110", @"111", @"105", @"116", @"97", @"114", @"117", @"103", @"105", @"102", @"110", @"111", @"67", @"110", @"111", @"105", @"115", @"115", @"101", @"115", @"161"];
		NSData *data = [WithoutSoilData WithoutSoilDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        _colorSceneUtility = [self StringFromWithoutSoilData:value];
    }
    return _colorSceneUtility;
}

//: <%@: %p, baseURL: %@, session: %@, operationQueue: %@>
- (NSString *)themeStandId {
    if (!_themeStandId) {
		NSArray<NSString *> *origin = @[@"54", @"7", @"65", @"30", @"151", @"121", @"70", @"62", @"64", @"37", @"32", @"58", @"101", @"117", @"101", @"117", @"81", @"110", @"111", @"105", @"116", @"97", @"114", @"101", @"112", @"111", @"32", @"44", @"64", @"37", @"32", @"58", @"110", @"111", @"105", @"115", @"115", @"101", @"115", @"32", @"44", @"64", @"37", @"32", @"58", @"76", @"82", @"85", @"101", @"115", @"97", @"98", @"32", @"44", @"112", @"37", @"32", @"58", @"64", @"37", @"60", @"61"];
		NSData *data = [WithoutSoilData WithoutSoilDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        _themeStandId = [self StringFromWithoutSoilData:value];
    }
    return _themeStandId;
}

//: Invalid parameter not satisfying: %@
- (NSString *)screenRemSimpleId {
    if (!_screenRemSimpleId) {
		NSArray<NSString *> *origin = @[@"36", @"12", @"47", @"236", @"189", @"7", @"25", @"16", @"42", @"45", @"158", @"62", @"64", @"37", @"32", @"58", @"103", @"110", @"105", @"121", @"102", @"115", @"105", @"116", @"97", @"115", @"32", @"116", @"111", @"110", @"32", @"114", @"101", @"116", @"101", @"109", @"97", @"114", @"97", @"112", @"32", @"100", @"105", @"108", @"97", @"118", @"110", @"73", @"233"];
		NSData *data = [WithoutSoilData WithoutSoilDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        _screenRemSimpleId = [self StringFromWithoutSoilData:value];
    }
    return _screenRemSimpleId;
}

//: https
- (NSString *)themeInfraImagineTitle {
    if (!_themeInfraImagineTitle) {
		NSArray<NSString *> *origin = @[@"5", @"8", @"72", @"158", @"211", @"162", @"223", @"48", @"115", @"112", @"116", @"116", @"104", @"179"];
		NSData *data = [WithoutSoilData WithoutSoilDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        _themeInfraImagineTitle = [self StringFromWithoutSoilData:value];
    }
    return _themeInfraImagineTitle;
}

//: AFSSLPinningModeCertificate
- (NSString *)commonStandConfig {
    if (!_commonStandConfig) {
		NSArray<NSString *> *origin = @[@"27", @"6", @"92", @"185", @"101", @"229", @"101", @"116", @"97", @"99", @"105", @"102", @"105", @"116", @"114", @"101", @"67", @"101", @"100", @"111", @"77", @"103", @"110", @"105", @"110", @"110", @"105", @"80", @"76", @"83", @"83", @"70", @"65", @"13"];
		NSData *data = [WithoutSoilData WithoutSoilDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        _commonStandConfig = [self StringFromWithoutSoilData:value];
    }
    return _commonStandConfig;
}

//: Invalid Security Policy
- (NSString *)screenAlongPreference {
    if (!_screenAlongPreference) {
		NSArray<NSString *> *origin = @[@"23", @"5", @"145", @"137", @"63", @"121", @"99", @"105", @"108", @"111", @"80", @"32", @"121", @"116", @"105", @"114", @"117", @"99", @"101", @"83", @"32", @"100", @"105", @"108", @"97", @"118", @"110", @"73", @"150"];
		NSData *data = [WithoutSoilData WithoutSoilDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        _screenAlongPreference = [self StringFromWithoutSoilData:value];
    }
    return _screenAlongPreference;
}

//: PATCH
- (NSString *)layoutRockInsertName {
    if (!_layoutRockInsertName) {
		NSArray<NSString *> *origin = @[@"5", @"11", @"43", @"156", @"225", @"127", @"156", @"200", @"237", @"252", @"251", @"72", @"67", @"84", @"65", @"80", @"50"];
		NSData *data = [WithoutSoilData WithoutSoilDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        _layoutRockInsertName = [self StringFromWithoutSoilData:value];
    }
    return _layoutRockInsertName;
}

//: HEAD
- (NSString *)appTensionConfig {
    if (!_appTensionConfig) {
		NSArray<NSString *> *origin = @[@"4", @"6", @"251", @"31", @"106", @"215", @"68", @"65", @"69", @"72", @"236"];
		NSData *data = [WithoutSoilData WithoutSoilDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        _appTensionConfig = [self StringFromWithoutSoilData:value];
    }
    return _appTensionConfig;
}

//: PUT
- (NSString *)layoutHourFabricLogger {
    if (!_layoutHourFabricLogger) {
		NSArray<NSString *> *origin = @[@"3", @"2", @"84", @"85", @"80", @"86"];
		NSData *data = [WithoutSoilData WithoutSoilDataToData:origin];
        Byte *value = (Byte *)data.bytes;
        _layoutHourFabricLogger = [self StringFromWithoutSoilData:value];
    }
    return _layoutHourFabricLogger;
}

@end

// __DEBUG__
// __CLOSE_PRINT__
// AFHTTPSessionManager.m
// Copyright (c) 2011â€“2016 Alamofire Software Foundation ( http://alamofire.org/ )
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// __M_A_C_R_O__
//: #import "AFHTTPSessionManager.h"
#import "AFHTTPSessionManager.h"
//: #import "AFURLRequestSerialization.h"
#import "AFURLRequestSerialization.h"
//: #import "AFURLResponseSerialization.h"
#import "AFURLResponseSerialization.h"
//: #import <Availability.h>
#import <Availability.h>
//: #import <TargetConditionals.h>
#import <TargetConditionals.h>
//: #import <Security/Security.h>
#import <Security/Security.h>
//: #import <netinet/in.h>
#import <netinet/in.h>
//: #import <arpa/inet.h>
#import <arpa/inet.h>
//: #import <ifaddrs.h>
#import <ifaddrs.h>
//: #import <netdb.h>
#import <netdb.h>
//: #import <UIKit/UIKit.h>
#import <UIKit/UIKit.h>

//: @interface AFHTTPSessionManager ()
@interface AFHTTPSessionManager ()
//: @property (readwrite, nonatomic, strong) NSURL *baseURL;
@property (readwrite, nonatomic, strong) NSURL *dressRelated;
//: @end
@end

//: @implementation AFHTTPSessionManager
@implementation AFHTTPSessionManager
//: @dynamic responseSerializer;
@dynamic unslopedDeeping;

//: @dynamic securityPolicy;
@dynamic identifyPorted;

//: - (void)setSecurityPolicy:(AFSecurityPolicy *)securityPolicy {
- (void)setIdentifyPorted:(AFSecurityPolicy *)securityPolicy {
    //: if (securityPolicy.SSLPinningMode != AFSSLPinningModeNone && ![self.baseURL.scheme isEqualToString:@"https"]) {
    if (securityPolicy.modeBorders != AFSSLPinningModeNone && ![self.dressRelated.scheme isEqualToString:@"https"]) {
        //: NSString *pinningMode = @"Unknown Pinning Mode";
        NSString *pinningMode = @"Unknown Pinning Mode";
        //: switch (securityPolicy.SSLPinningMode) {
        switch (securityPolicy.modeBorders) {
            //: case AFSSLPinningModeNone: pinningMode = @"AFSSLPinningModeNone"; break;
            case AFSSLPinningModeNone: pinningMode = @"AFSSLPinningModeNone"; break;
            //: case AFSSLPinningModeCertificate: pinningMode = @"AFSSLPinningModeCertificate"; break;
            case AFSSLPinningModeCertificate: pinningMode = @"AFSSLPinningModeCertificate"; break;
            //: case AFSSLPinningModePublicKey: pinningMode = @"AFSSLPinningModePublicKey"; break;
            case AFSSLPinningModePublicKey: pinningMode = @"AFSSLPinningModePublicKey"; break;
        }
        //: NSString *reason = [NSString stringWithFormat:@"A security policy configured with `%@` can only be applied on a manager with a secure base URL (i.e. https)", pinningMode];
        NSString *reason = [NSString stringWithFormat:@"A security policy configured with `%@` can only be applied on a manager with a secure base URL (i.e. https)", pinningMode];
        //: @throw [NSException exceptionWithName:@"Invalid Security Policy" reason:reason userInfo:nil];
        @throw [NSException exceptionWithName:@"Invalid Security Policy" reason:reason userInfo:nil];
    }

    //: [super setSecurityPolicy:securityPolicy];
    [super setIdentifyPorted:securityPolicy];
}

//: #pragma mark -
#pragma mark -

//: - (NSURLSessionDataTask *)GET:(NSString *)URLString
- (NSURLSessionDataTask *)flameGet:(NSString *)URLString
                   //: parameters:(nullable id)parameters
                   timeQuantity:(nullable id)parameters
                      //: headers:(nullable NSDictionary <NSString *, NSString *> *)headers
                      joint:(nullable NSDictionary <NSString *, NSString *> *)headers
                     //: progress:(nullable void (^)(NSProgress * _Nonnull))downloadProgress
                     retention:(nullable void (^)(NSProgress * _Nonnull))downloadProgress
                      //: success:(nullable void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success
                      getClick:(nullable void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success
                      //: failure:(nullable void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure
                      tactic:(nullable void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure
{

    //: NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@"GET"
    NSURLSessionDataTask *dataTask = [self arrow:@"GET"
                                                        //: URLString:URLString
                                                        rear_strong:URLString
                                                       //: parameters:parameters
                                                       cardinalStream:parameters
                                                          //: headers:headers
                                                          fromFailure:headers
                                                   //: uploadProgress:nil
                                                   add:nil
                                                 //: downloadProgress:downloadProgress
                                                 program:downloadProgress
                                                          //: success:success
                                                          progressShore:success
                                                          //: failure:failure];
                                                          figure:failure];

    //: [dataTask resume];
    [dataTask resume];

    //: return dataTask;
    return dataTask;
}

//: - (instancetype)initWithCoder:(NSCoder *)decoder {
- (instancetype)initWithCoder:(NSCoder *)decoder {
    //: NSURL *baseURL = [decoder decodeObjectOfClass:[NSURL class] forKey:NSStringFromSelector(@selector(baseURL))];
    NSURL *baseURL = [decoder decodeObjectOfClass:[NSURL class] forKey:NSStringFromSelector(@selector(dressRelated))];
    //: NSURLSessionConfiguration *configuration = [decoder decodeObjectOfClass:[NSURLSessionConfiguration class] forKey:@"sessionConfiguration"];
    NSURLSessionConfiguration *configuration = [decoder decodeObjectOfClass:[NSURLSessionConfiguration class] forKey:@"sessionConfiguration"];
    //: if (!configuration) {
    if (!configuration) {
        //: NSString *configurationIdentifier = [decoder decodeObjectOfClass:[NSString class] forKey:@"identifier"];
        NSString *configurationIdentifier = [decoder decodeObjectOfClass:[NSString class] forKey:@"identifier"];
        //: if (configurationIdentifier) {
        if (configurationIdentifier) {
            //: configuration = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:configurationIdentifier];
            configuration = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:configurationIdentifier];
        }
    }

    //: self = [self initWithBaseURL:baseURL sessionConfiguration:configuration];
    self = [self initWithToe:baseURL weekScience:configuration];
    //: if (!self) {
    if (!self) {
        //: return nil;
        return nil;
    }

    //: self.requestSerializer = [decoder decodeObjectOfClass:[AFHTTPRequestSerializer class] forKey:NSStringFromSelector(@selector(requestSerializer))];
    self.treatFriending = [decoder decodeObjectOfClass:[AFHTTPRequestSerializer class] forKey:NSStringFromSelector(@selector(treatFriending))];
    //: self.responseSerializer = [decoder decodeObjectOfClass:[AFHTTPResponseSerializer class] forKey:NSStringFromSelector(@selector(responseSerializer))];
    self.unslopedDeeping = [decoder decodeObjectOfClass:[AFHTTPResponseSerializer class] forKey:NSStringFromSelector(@selector(unslopedDeeping))];
    //: AFSecurityPolicy *decodedPolicy = [decoder decodeObjectOfClass:[AFSecurityPolicy class] forKey:NSStringFromSelector(@selector(securityPolicy))];
    AFSecurityPolicy *decodedPolicy = [decoder decodeObjectOfClass:[AFSecurityPolicy class] forKey:NSStringFromSelector(@selector(identifyPorted))];
    //: if (decodedPolicy) {
    if (decodedPolicy) {
        //: self.securityPolicy = decodedPolicy;
        self.identifyPorted = decodedPolicy;
    }

    //: return self;
    return self;
}

//: - (instancetype)initWithBaseURL:(NSURL *)url {
- (instancetype)initWithSparkUrl:(NSURL *)url {
    //: return [self initWithBaseURL:url sessionConfiguration:nil];
    return [self initWithToe:url weekScience:nil];
}

//: - (NSURLSessionDataTask *)POST:(NSString *)URLString
- (NSURLSessionDataTask *)layer:(NSString *)URLString
                    //: parameters:(nullable id)parameters
                    request:(nullable id)parameters
                       //: headers:(nullable NSDictionary<NSString *,NSString *> *)headers
                       arrangement:(nullable NSDictionary<NSString *,NSString *> *)headers
     //: constructingBodyWithBlock:(nullable void (^)(id<AFMultipartFormData> _Nonnull))block
     resume:(nullable void (^)(id<AFMultipartFormData> _Nonnull))block
                      //: progress:(nullable void (^)(NSProgress * _Nonnull))uploadProgress
                      progress:(nullable void (^)(NSProgress * _Nonnull))uploadProgress
                       //: success:(nullable void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure
                       genuineFailure:(nullable void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success treatIngot:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure
{
    //: NSError *serializationError = nil;
    NSError *serializationError = nil;
    //: NSMutableURLRequest *request = [self.requestSerializer multipartFormRequestWithMethod:@"POST" URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters constructingBodyWithBlock:block error:&serializationError];
    NSMutableURLRequest *request = [self.treatFriending sign:@"POST" multipart:[[NSURL URLWithString:URLString relativeToURL:self.dressRelated] absoluteString] tin:parameters administrator:block aqueousSolution:&serializationError];
    //: for (NSString *headerField in headers.keyEnumerator) {
    for (NSString *headerField in headers.keyEnumerator) {
        //: [request setValue:headers[headerField] forHTTPHeaderField:headerField];
        [request setValue:headers[headerField] forHTTPHeaderField:headerField];
    }
    //: if (serializationError) {
    if (serializationError) {
        //: if (failure) {
        if (failure) {
            //: dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{
            dispatch_async(self.globalLess ?: dispatch_get_main_queue(), ^{
                //: failure(nil, serializationError);
                failure(nil, serializationError);
            //: });
            });
        }

        //: return nil;
        return nil;
    }

    //: __block NSURLSessionDataTask *task = [self uploadTaskWithStreamedRequest:request progress:uploadProgress completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) {
    __block NSURLSessionDataTask *task = [self output:request disable:uploadProgress correlativity:^(NSURLResponse * __unused response, id responseObject, NSError *error) {
        //: if (error) {
        if (error) {
            //: if (failure) {
            if (failure) {
                //: failure(task, error);
                failure(task, error);
            }
        //: } else {
        } else {
            //: if (success) {
            if (success) {
                //: success(task, responseObject);
                success(task, responseObject);
            }
        }
    //: }];
    }];

    //: [task resume];
    [task resume];

    //: return task;
    return task;
}

//: - (instancetype)init {
- (instancetype)init {
    //: return [self initWithBaseURL:nil];
    return [self initWithSparkUrl:nil];
}

//: - (nullable NSURLSessionDataTask *)POST:(NSString *)URLString
- (nullable NSURLSessionDataTask *)spotBefore:(NSString *)URLString
                             //: parameters:(nullable id)parameters
                             speed:(nullable id)parameters
                                //: headers:(nullable NSDictionary <NSString *, NSString *> *)headers
                                be:(nullable NSDictionary <NSString *, NSString *> *)headers
                               //: progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress
                               flunk:(nullable void (^)(NSProgress *uploadProgress))uploadProgress
                                //: success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success
                                lakeFailure:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success
                                //: failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure
                                dent:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure
{
    //: NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@"POST" URLString:URLString parameters:parameters headers:headers uploadProgress:uploadProgress downloadProgress:nil success:success failure:failure];
    NSURLSessionDataTask *dataTask = [self arrow:@"POST" rear_strong:URLString cardinalStream:parameters fromFailure:headers add:uploadProgress program:nil progressShore:success figure:failure];

    //: [dataTask resume];
    [dataTask resume];

    //: return dataTask;
    return dataTask;
}

//: #pragma mark -
#pragma mark -

//: - (void)setRequestSerializer:(AFHTTPRequestSerializer <AFURLRequestSerialization> *)requestSerializer {
- (void)setTreatFriending:(AFHTTPRequestSerializer <AFURLRequestSerialization> *)requestSerializer {
    //: NSParameterAssert(requestSerializer);
    NSParameterAssert(requestSerializer);

    //: _requestSerializer = requestSerializer;
    _treatFriending = requestSerializer;
}

//: - (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method
- (NSURLSessionDataTask *)arrow:(NSString *)method
                                       //: URLString:(NSString *)URLString
                                       rear_strong:(NSString *)URLString
                                      //: parameters:(nullable id)parameters
                                      cardinalStream:(nullable id)parameters
                                         //: headers:(nullable NSDictionary <NSString *, NSString *> *)headers
                                         fromFailure:(nullable NSDictionary <NSString *, NSString *> *)headers
                                  //: uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress
                                  add:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress
                                //: downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress
                                program:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress
                                         //: success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success
                                         progressShore:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success
                                         //: failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure
                                         figure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure
{
    //: NSError *serializationError = nil;
    NSError *serializationError = nil;
    //: NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&serializationError];
    NSMutableURLRequest *request = [self.treatFriending areaWord:method selfPropelledVehicle:[[NSURL URLWithString:URLString relativeToURL:self.dressRelated] absoluteString] correlation:parameters command:&serializationError];
    //: for (NSString *headerField in headers.keyEnumerator) {
    for (NSString *headerField in headers.keyEnumerator) {
        //: [request setValue:headers[headerField] forHTTPHeaderField:headerField];
        [request setValue:headers[headerField] forHTTPHeaderField:headerField];
    }
    //: if (serializationError) {
    if (serializationError) {
        //: if (failure) {
        if (failure) {
            //: dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{
            dispatch_async(self.globalLess ?: dispatch_get_main_queue(), ^{
                //: failure(nil, serializationError);
                failure(nil, serializationError);
            //: });
            });
        }

        //: return nil;
        return nil;
    }

    //: __block NSURLSessionDataTask *dataTask = nil;
    __block NSURLSessionDataTask *dataTask = nil;
    //: dataTask = [self dataTaskWithRequest:request
    dataTask = [self derive:request
                          //: uploadProgress:uploadProgress
                          stick:uploadProgress
                        //: downloadProgress:downloadProgress
                        water:downloadProgress
                       //: completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) {
                       master:^(NSURLResponse * __unused response, id responseObject, NSError *error) {
        //: if (error) {
        if (error) {
            //: if (failure) {
            if (failure) {
                //: failure(dataTask, error);
                failure(dataTask, error);
            }
        //: } else {
        } else {
            //: if (success) {
            if (success) {
                //: success(dataTask, responseObject);
                success(dataTask, responseObject);
            }
        }
    //: }];
    }];

    //: return dataTask;
    return dataTask;
}

//: - (instancetype)initWithBaseURL:(NSURL *)url
- (instancetype)initWithToe:(NSURL *)url
           //: sessionConfiguration:(NSURLSessionConfiguration *)configuration
           weekScience:(NSURLSessionConfiguration *)configuration
{
    //: self = [super initWithSessionConfiguration:configuration];
    self = [super initWithTotalro:configuration];
    //: if (!self) {
    if (!self) {
        //: return nil;
        return nil;
    }

    // Ensure terminal slash for baseURL path, so that NSURL +URLWithString:relativeToURL: works as expected
    //: if ([[url path] length] > 0 && ![[url absoluteString] hasSuffix:@"/"]) {
    if ([[url path] length] > 0 && ![[url absoluteString] hasSuffix:@"/"]) {
        //: url = [url URLByAppendingPathComponent:@""];
        url = [url URLByAppendingPathComponent:@""];
    }

    //: self.baseURL = url;
    self.dressRelated = url;

    //: self.requestSerializer = [AFHTTPRequestSerializer serializer];
    self.treatFriending = [AFHTTPRequestSerializer together];
    //: self.responseSerializer = [AFJSONResponseSerializer serializer];
    self.unslopedDeeping = [AFJSONResponseSerializer sweetCommendation];

    //: return self;
    return self;
}

//: - (void)setResponseSerializer:(AFHTTPResponseSerializer <AFURLResponseSerialization> *)responseSerializer {
- (void)setUnslopedDeeping:(AFHTTPResponseSerializer <AFURLResponseSerialization> *)responseSerializer {
    //: NSParameterAssert(responseSerializer);
    NSParameterAssert(responseSerializer);

    //: [super setResponseSerializer:responseSerializer];
    [super setUnslopedDeeping:responseSerializer];
}

//: #pragma mark - NSSecureCoding
#pragma mark - NSSecureCoding

//: + (BOOL)supportsSecureCoding {
+ (BOOL)supportsSecureCoding {
    //: return YES;
    return YES;
}

//: #pragma mark - NSObject
#pragma mark - NSObject

//: - (NSString *)description {
- (NSString *)description {
    //: return [NSString stringWithFormat:@"<%@: %p, baseURL: %@, session: %@, operationQueue: %@>", NSStringFromClass([self class]), self, [self.baseURL absoluteString], self.session, self.operationQueue];
    return [NSString stringWithFormat:@"<%@: %p, baseURL: %@, session: %@, operationQueue: %@>", NSStringFromClass([self class]), self, [self.dressRelated absoluteString], self.personalThread, self.forbidCancelQueue];
}

//: + (instancetype)manager {
+ (instancetype)angle {
    //: return [[[self class] alloc] initWithBaseURL:nil];
    return [[[self class] alloc] initWithSparkUrl:nil];
}

//: - (NSURLSessionDataTask *)DELETE:(NSString *)URLString
- (NSURLSessionDataTask *)pulverization:(NSString *)URLString
                      //: parameters:(nullable id)parameters
                      resolveId:(nullable id)parameters
                         //: headers:(nullable NSDictionary<NSString *,NSString *> *)headers
                         action:(nullable NSDictionary<NSString *,NSString *> *)headers
                         //: success:(nullable void (^)(NSURLSessionDataTask *task, id responseObject))success
                         partPad:(nullable void (^)(NSURLSessionDataTask *task, id responseObject))success
                         //: failure:(nullable void (^)(NSURLSessionDataTask *task, NSError *error))failure
                         mount:(nullable void (^)(NSURLSessionDataTask *task, NSError *error))failure
{
    //: NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@"DELETE" URLString:URLString parameters:parameters headers:headers uploadProgress:nil downloadProgress:nil success:success failure:failure];
    NSURLSessionDataTask *dataTask = [self arrow:@"DELETE" rear_strong:URLString cardinalStream:parameters fromFailure:headers add:nil program:nil progressShore:success figure:failure];

    //: [dataTask resume];
    [dataTask resume];

    //: return dataTask;
    return dataTask;
}


//: - (NSURLSessionDataTask *)PATCH:(NSString *)URLString
- (NSURLSessionDataTask *)hoard:(NSString *)URLString
                     //: parameters:(nullable id)parameters
                     shared:(nullable id)parameters
                        //: headers:(nullable NSDictionary<NSString *,NSString *> *)headers
                        task:(nullable NSDictionary<NSString *,NSString *> *)headers
                        //: success:(nullable void (^)(NSURLSessionDataTask *task, id responseObject))success
                        mark:(nullable void (^)(NSURLSessionDataTask *task, id responseObject))success
                        //: failure:(nullable void (^)(NSURLSessionDataTask *task, NSError *error))failure
                        distinct:(nullable void (^)(NSURLSessionDataTask *task, NSError *error))failure
{
    //: NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@"PATCH" URLString:URLString parameters:parameters headers:headers uploadProgress:nil downloadProgress:nil success:success failure:failure];
    NSURLSessionDataTask *dataTask = [self arrow:@"PATCH" rear_strong:URLString cardinalStream:parameters fromFailure:headers add:nil program:nil progressShore:success figure:failure];

    //: [dataTask resume];
    [dataTask resume];

    //: return dataTask;
    return dataTask;
}

//: - (NSURLSessionDataTask *)PUT:(NSString *)URLString
- (NSURLSessionDataTask *)operation:(NSString *)URLString
                   //: parameters:(nullable id)parameters
                   pattyPanFailure:(nullable id)parameters
                      //: headers:(nullable NSDictionary<NSString *,NSString *> *)headers
                      star:(nullable NSDictionary<NSString *,NSString *> *)headers
                      //: success:(nullable void (^)(NSURLSessionDataTask *task, id responseObject))success
                      cut:(nullable void (^)(NSURLSessionDataTask *task, id responseObject))success
                      //: failure:(nullable void (^)(NSURLSessionDataTask *task, NSError *error))failure
                      tableOfTexts:(nullable void (^)(NSURLSessionDataTask *task, NSError *error))failure
{
    //: NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@"PUT" URLString:URLString parameters:parameters headers:headers uploadProgress:nil downloadProgress:nil success:success failure:failure];
    NSURLSessionDataTask *dataTask = [self arrow:@"PUT" rear_strong:URLString cardinalStream:parameters fromFailure:headers add:nil program:nil progressShore:success figure:failure];

    //: [dataTask resume];
    [dataTask resume];

    //: return dataTask;
    return dataTask;
}

//: - (NSURLSessionDataTask *)HEAD:(NSString *)URLString
- (NSURLSessionDataTask *)shallowness:(NSString *)URLString
                    //: parameters:(nullable id)parameters
                    corner:(nullable id)parameters
                       //: headers:(nullable NSDictionary<NSString *,NSString *> *)headers
                       available:(nullable NSDictionary<NSString *,NSString *> *)headers
                       //: success:(nullable void (^)(NSURLSessionDataTask * _Nonnull))success
                       perFailure:(nullable void (^)(NSURLSessionDataTask * _Nonnull))success
                       //: failure:(nullable void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure
                       example:(nullable void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure
{
    //: NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@"HEAD" URLString:URLString parameters:parameters headers:headers uploadProgress:nil downloadProgress:nil success:^(NSURLSessionDataTask *task, __unused id responseObject) {
    NSURLSessionDataTask *dataTask = [self arrow:@"HEAD" rear_strong:URLString cardinalStream:parameters fromFailure:headers add:nil program:nil progressShore:^(NSURLSessionDataTask *task, __unused id responseObject) {
        //: if (success) {
        if (success) {
            //: success(task);
            success(task);
        }
    //: } failure:failure];
    } figure:failure];

    //: [dataTask resume];
    [dataTask resume];

    //: return dataTask;
    return dataTask;
}

//: - (void)encodeWithCoder:(NSCoder *)coder {
- (void)encodeWithCoder:(NSCoder *)coder {
    //: [super encodeWithCoder:coder];
    [super encodeWithCoder:coder];

    //: [coder encodeObject:self.baseURL forKey:NSStringFromSelector(@selector(baseURL))];
    [coder encodeObject:self.dressRelated forKey:NSStringFromSelector(@selector(dressRelated))];
    //: if ([self.session.configuration conformsToProtocol:@protocol(NSCoding)]) {
    if ([self.personalThread.configuration conformsToProtocol:@protocol(NSCoding)]) {
        //: [coder encodeObject:self.session.configuration forKey:@"sessionConfiguration"];
        [coder encodeObject:self.personalThread.configuration forKey:@"sessionConfiguration"];
    //: } else {
    } else {
        //: [coder encodeObject:self.session.configuration.identifier forKey:@"identifier"];
        [coder encodeObject:self.personalThread.configuration.identifier forKey:@"identifier"];
    }
    //: [coder encodeObject:self.requestSerializer forKey:NSStringFromSelector(@selector(requestSerializer))];
    [coder encodeObject:self.treatFriending forKey:NSStringFromSelector(@selector(treatFriending))];
    //: [coder encodeObject:self.responseSerializer forKey:NSStringFromSelector(@selector(responseSerializer))];
    [coder encodeObject:self.unslopedDeeping forKey:NSStringFromSelector(@selector(unslopedDeeping))];
    //: [coder encodeObject:self.securityPolicy forKey:NSStringFromSelector(@selector(securityPolicy))];
    [coder encodeObject:self.identifyPorted forKey:NSStringFromSelector(@selector(identifyPorted))];
}

//: - (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration {
- (instancetype)initWithTotalro:(NSURLSessionConfiguration *)configuration {
    //: return [self initWithBaseURL:nil sessionConfiguration:configuration];
    return [self initWithToe:nil weekScience:configuration];
}

//: #pragma mark - NSCopying
#pragma mark - NSCopying

//: - (instancetype)copyWithZone:(NSZone *)zone {
- (instancetype)copyWithZone:(NSZone *)zone {
    //: AFHTTPSessionManager *HTTPClient = [[[self class] allocWithZone:zone] initWithBaseURL:self.baseURL sessionConfiguration:self.session.configuration];
    AFHTTPSessionManager *HTTPClient = [[[self class] allocWithZone:zone] initWithToe:self.dressRelated weekScience:self.personalThread.configuration];

    //: HTTPClient.requestSerializer = [self.requestSerializer copyWithZone:zone];
    HTTPClient.treatFriending = [self.treatFriending copyWithZone:zone];
    //: HTTPClient.responseSerializer = [self.responseSerializer copyWithZone:zone];
    HTTPClient.unslopedDeeping = [self.unslopedDeeping copyWithZone:zone];
    //: HTTPClient.securityPolicy = [self.securityPolicy copyWithZone:zone];
    HTTPClient.identifyPorted = [self.identifyPorted copyWithZone:zone];
    //: return HTTPClient;
    return HTTPClient;
}

//: @end
@end